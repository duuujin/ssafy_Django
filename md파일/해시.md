# 해시 (Hash)
- 임의의 크기를 가진 데이터를 고정된 크기의 **고유한 값**으로 변환하는 것

# 해시함수 (Hash Function)
- 임의 길이 데이터를 입력 받아 **고정 길이(정수)**로 변환해 주는 함수

# 해시함수 특징
- 어떤 길이의 데이터든 넣을 수 있고, 항상 고정된 길이의 결과물(해시값)이 나옴
- 입력값으로 해시값을 만들 수는 있지만, 해시값만 보고 원래 입력값을 알아낼 수 없음 ( 단방향 )
- 입력값이 단 한 글자만 달라져도 해시값은 완전히 달라짐(눈사태효과)
- 같은 입력값을 넣으면 언제나 똑같은 해시값이 나옴

# 해시
- 데이터를 고정된 크기의 값으로 변환하는 과정
- 작은 변화에도 해시값이 크게 달라지는 특성으로 인해 변조 여부를 쉽게 확인 할 수 있음
- 입력값이 들어오더라도 해시 함수에 의해서 다른 값으로 바뀌며, 동일한 값은 항상 동일한 해시값을 생성

# Django의 암호화
- Django 는 기본적으로 **SHA-256** 해시 함수를 사용해서 암호화
- 입력한 비밀번호의 길이와는 상관없이 동일한 길이의 해시값을 생성
- 1글자만 다르더라도 전혀 다른 해시값을 생성

# SHA-256 ( Secure Hash Algorithm - 256 )
- 안전한 해시 알고리즘으로, 어떤 데이터를 입력하든 256비트 길이의 결과물을 만들어 냄

# 해시 함수를 활용해 단방향 암호화는 문제 없을 까 ?
- 공격자들은 미리 계산해두는 방식으로 공격을 시도
- 이것이 바로 **레인보우 테이블**공격

# 레인보우 테이블
- 공격자가 자주 사용하는 비밀번호들을 **미리 수백만, 수십억 개를 해시로 변환**해 저장해 둔 거대한 정답지

# 레인보우 테이블 공격 방식
- DB를 탈취해 사용자의 비밀번호 해시 값을 얻음
- 자신의 레인보우 테이블에서 검색
- 일치되는 값을 찾아내면서, 역방향으로 되돌리지 않고 비밀번호 찾는데 성공

# 레인보우 테이블을 어떻게 방어
- 같은 비밀번호라도 사용자마다 **임의의 문자열**을 비밀번호에 붙여 해시 암호화 진행
- 임의의 문자열 역할을 하는 것이 바로 **솔트**

# 솔트(Salt)
- 임의의 문자열 (솔트)를 비번에 덧붙여서 해시 값을 생성

# 공격자가 알아도 되냐
- 상관 XX
- **하나의 답안지로 수백만명 공격하는 방식**에서 **한명을 공격하기 위해 매번 새로운 답지를 만드는 방식**으로 바뀌면서, 효율성을 떨어뜨림

# 솔트로 레인보우 막으니, 안전 ??
- **가능한 모든 비밀번호를 하나씩 직접 대입**하는 방식으로 공격
- 이 방식은 현대 컴퓨터의 엄청난 속도 때문에 생각보다 훨씬 위협적
- 이 방식이 바로 **무차별 대입 공격(Brute-force Attack)**

# 무차별 대입 공격(Brute-force Attack)
- 가장 원시적이지만 가능한 모든 비밀번호를 하나씩 대입
- 현대 컴터의 **빠른 연산 속도**가 무기

# 무차별 대입 공격을 막는 법
- 연산 속도를 늦추는 것이 핵심
- 이 방식이 바로 **키 스트레칭(Key Stretching)**

# 키 스트레칭 (Key Stretching)
- 솔트(Salt)를 적용한 해시 함수를 수만 ~ 수십만 번 반복하여 연산 시간을 의도적으로 늘리는 기법
- 속도가 무기인 무차별 대입 공격을 막을 수 있음
- Django는 이를 구현하기 위해 PBKDF2라는 검증된 알고리즘을 기본으로 사용


# 비밀번호 암호화 정리
- 검증된 프레임워크의 보안 기능을 신뢰하고 사용하기
- 이 기능이 **왜** 이렇게 만들어졌는지 이해하면, 더 견고하고 안전한 어플리케이션을 만들 수 있음
- 사용자의 데이터를 안전하게 지키는 것은 개발자의 **가장 기본적인 책임이자 직업윤리**